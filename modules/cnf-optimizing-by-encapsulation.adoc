// Module included in the following assemblies:
//
// * scalability_and_performance/optimizing-cpu-usage.adoc

[id="optimizing-by-encapsulation_{context}"]
= Encapsulating mount namespaces

Mount namespaces are used to isolate mount points so that processes in different namespaces cannot access files in other namespaces. You can _encapsulate_ a mount namespace by moving it to an alternative location. This is useful when you want the mount namespace to be hidden from other processes.

In the host OS, `systemd` constantly scans all Linux and Kubernetes mount namespaces. By encapsulating container-specific mountpoints in a private namespace, you can reduce `systemd` overhead with no difference in functionality. You can encapsulate container-specific mounts from any `systemd` or other host OS interaction using a separate mount namespace for both CRI-O or Kubelet processes.

The following diagram illustrates an {product-title} installation with encapsulated system processes.

.{product-title} architecture with encapsulated processes
image::after-k8s-mount-propagation.png[{product-title} architecture with encapsulated processes]

* `systemd` scans systemd-specific and host mountpoints only, and is visible to `systemd` instances in the container space.

* The host OS processes access the top-level namespace at `run/host`.

* CRI-O and Kubelet processes use a separate mount namespace. This segregates all container-specific mounts away from any `systemd` or other host OS interactions.

* In container 1, mounts originating in CRI-O, and Kubelet, and container volume mounts with bidirectional mount propagation are no longer visible to `systemd` or the host OS.

* In container 2, mounts originating in the host OS are still visible to CRI-O, Kubelet, and container volume mounts with host-to-container or bidirectional mount propagation.

* In container 3, mounts originating in CRI-O, Kubelet, and container volume mounts with no propagation are not visible.
