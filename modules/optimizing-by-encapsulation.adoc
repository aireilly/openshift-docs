// Module included in the following assemblies:
//
// * scalability_and_performance/optimizing-cpu-usage.adoc

[id="optimizing-cpu-usage_{context}"]
= Encapsulating mount namespaces

Mount namespaces are used to isolate mount points so that processes in different namespaces cannot view each others' files. Encapsulation is the process of moving mount namespaces to an alternative location, known to the owner but hidden from intrusive visitors.

The host operating system uses `systemd` to constantly scan all mount namespaces: both the standard Linux mounts and the numerous mounts that Kubernetes uses to operate. The current implementation of Kubelet and CRI-O both use the top-level namespace for all container and Kubelet mountpoints. However, encapsulating these container-specific mountpoints in a private namespace reduces `systemd` overhead with no difference in functionality. Using a separate mount namespace for both CRI-O and Kubelet can encapsulate container-specific mounts from any `systemd` or other host OS interaction.

This ability to potentially achieve major CPU optimization is now available to all {product-title} administrators. Encapsulation can also improve security, by storing Kubernetes-specific mount points in a location safe from inspection by unprivileged users.

== How encapsulation works
The following diagrams illustrate a Kubernetes installation before and after encapsulation. Both scenarios show example containers which have mount propagation settings of bidirectional, host-to-container, and none.

image::before-k8s-mount-propagation.png[Before encapsulation]

Here we see `systemd`, host OS processes, `kubelet`, and the container runtime pooling access to all mount namespaces. There is no optimisation of CPU usage.

The following diagram illustrates the system state after encapsulation.

image::after-k8s-mount-propagation.png[After encapsulation]

* The main `systemd` scanning process is no longer devoted to unnecessary scanning of Kubernetes-specific mount points. It scans systemd-specific and host mountpoints, and is visible to `systemd` instances in the container space.

* The host OS processes access the top-level namespace at `run/host`.

* Using a separate mount namespace for both CRI-O and Kubelet completely segregates all container-specific mounts away from any `systemd` or other host OS interaction whatsoever.

* In Container A, mounts originating in CRI-O, and Kubelet, and container volume mounts with bidirectional mount propagation are no longer visible to `systemd` or the host OS.

* In Container B, mounts originating in the host OS are still visible to CRI-O, Kubelet, and container volume mounts with host-to-container or bidirectional mount propagation.

* In Container C, mounts originating in CRI-O, Kubelet, and container volume mounts with no propagation are not visible.
